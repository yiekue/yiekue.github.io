[{"title":"Bundle Adjustment","date":"2019-06-16T14:03:28.065Z","path":"2019/06/16/Bundle Adjustment/","text":"为了描述简便，用函数 $f(x)$ 来表示我们的目标函数，其中 $x$ 是包含了我们所有参数的向量，现在我们的目标就成了求解 $f(x)$ 在何处取得极小值。这个函数的参数这么多，很明显不能直接一步到位，但是从某个值出发（对于三维重建的问题，这个出发点已经有了，就是前面计算出来的相机姿态和三维点坐标）慢慢向正确的值靠近，一次靠近一丢丢（$\\delta x$），很多次后就可以很接近或者达到正确的值了。于是嘛，问题又变了，变成了我们一次靠近多少的问题了。。。问题变到这儿，貌似就有现成的方法可以解决啦。 梯度下降（最速下降）法从名字就可以看出来，这个方法是用了梯度信息。梯度的方向是函数上升最快的方向，我们要求的是最小值，那就沿着梯度方向的反方向进行靠近就可以了嘛。于是梯度下降法就是每次沿着梯度反方向以一个给定的步长进行逼近，这样就可以一步一步的靠近最小值。 这个方法虽然可以保证每一次都是在下降，但是下降的速度却并不像它的名字那样很快，收敛的速度较慢。 牛顿法这篇文章 很好的解释了牛顿法的原理，但是貌似只能求零点啊，这个求极值有啥关系，函数导数为0的地方不就是极值么。。假设在第$k$ 次迭代的时候，我们的参数向量为$x_k$ ，本次迭代的增量为 $\\delta x_k$ (也就是本次迭代要求解的东西)，那么函数就变成了$f(x_k+\\delta x_k)$ ，首先将这个函数进行泰勒展开到二次项：$$f(x_k+\\delta x_k) \\approx f(x_k) + \\delta x_k f’(x_k) +\\frac{1}{2} (\\delta x_k)^2 f’’(x_k) = \\phi(\\delta x_k)$$然后对$\\phi(\\delta x_k)$ 求导：$$\\phi ‘(\\delta x_k) = f’(x_k) + f’’(x_k)\\delta x_k$$令上面的导数为0就可以求得$\\delta x_k$ ，但是需要注意的是，$x_k、\\delta x_k$ 都是向量，所以$f’(x_k)、f’’(x_k)$ 都是矩阵，它们分别叫做雅可比（Jacobi）矩阵(记为$J$)和海森(Hessian)矩阵(记为$H$)，雅克比矩阵是函数对所有参数求一阶偏导得到，海森矩阵是函数对所有参数求二阶偏导得到。于是：$$J+H\\delta x_k = 0 \\\\delta x_k = -H^{-1}J$$这种方法下降速度比梯度下降要快很多（至于为啥快，我就不知道了，，），但是他不能保证每次迭代都是在下降的（但是总体是在下降的）。这样貌似问题解决了，但是，回头去看看我们的函数，要对这个函数求二阶偏导，简直太复杂了，大家选择放弃，，，， 高斯牛顿法牛顿大神把问题解决了一半，高斯大神决定再帮他一把，解决海森矩阵的问题，至于解决方式嘛，，，，就是不求它。我们在泰勒展开的时候就只展开到一次项：$$f(x_k+\\delta x_k) \\approx f(x_k)+ J\\delta x_k$$这样貌似等式右边就变成了类型$ax+b$ 这种线性的形式了啊，这懒偷得有点多了，必须找其他的约束补回来，，，比如我们的优化的是重投影误差，我们最希望它为零啊，，，于是嘛就直接令上式为零就得到了：$$f(x_k) + J\\delta x_k = 0$$貌似$\\delta x_k​$ 就可以求出来了：$\\delta x_k = -J^{-1}f(x_k)​$ ，但是总感觉有啥不对，，，恩，$J​$ 的大小是$m\\times n​$ 的，它可能不是一个方阵！！！所以它是不能直接求逆的，所以需要按照这样算：$$f(x_k) + J\\delta x_k = 0 \\J^Tf(x_k) + J^TJ\\delta x_k = 0 \\\\delta x_k = -(J^TJ)^{-1}J^Tf(x_k)$$ 这里可以看出来高斯牛顿法是利用了我们目标函数的特性来使用雅克比矩阵近似海森矩阵。这里只是解决了不计算海森矩阵，但是它还是存在不能保证每次迭代都是在下降的问题。 Levenberg-Marquard算法梯度下降可以保证每次迭代都是下降的，但是收敛慢，高斯牛顿收敛快但是不能保证每次迭代都是下降的。于是LM算法就出现啦，它把梯度下降和高斯牛顿法结合了起来，使得每次迭代都是下降的，而且收敛速度还比较快。至于怎么结合的，简直不能更粗暴，用一个参数$\\lambda$ 来控制增量计算方式是靠近高斯牛顿迭代的方法还是靠近梯度下降的方法，它把上面计算增量的方程改成了下面的形式：$$\\delta x_k = -[J^TJ+\\lambda diag(J^TJ)]^{-1} J^Tf(x_k)$$可以看出来$\\lambda$ 很小甚至为零时，增量计算方式和高斯牛顿迭代的方法是一致的；当$\\lambda$ 很大的时候，大到$J^TJ$ 可以忽略的时候，就变成了：$$\\delta x_k = -\\lambda J^Tf(x_k)$$恩，长得和梯度下降的式子挺像的。目前的Bundle Adjustment貌似都是基于LM算法实现的。 雅克比矩阵上面提到了很多次雅克比矩阵，甚至于每次迭代都需要计算一次雅克比矩阵，雅克比又是个啥？对于我们三维重建的问题，我们期望优化的参数有相机姿态$[R\\ \\ \\ t]$ ，这里一共有6个未知数（为啥是6个？因为旋转矩阵 $R$ 的自由度为3，事实上也可以用罗德里格斯公式转化为一个三维的向量$(r_1,r_2,r_3)$，位移向量$t$ 是长度为3的向量$(t_1,t_2,t_3)$），三维点的坐标$(x,y,z)$ 也就是一共就，9个参数。那么雅克比矩阵就一共有9列，每一列就是函数$f(x)$ 对不同的参数进行求偏导，这一列的元素值就是这个偏导数在一组参数下的取值：$$J = [\\frac{\\partial f}{\\partial r_1} \\ \\ \\frac{\\partial f}{\\partial r_2} \\ \\ \\frac{\\partial f}{\\partial r_3} \\ \\ \\frac{\\partial f}{\\partial t_1} \\ \\ \\frac{\\partial f}{\\partial t_2} \\ \\ \\frac{\\partial f}{\\partial t_3} \\ \\ \\frac{\\partial f}{\\partial x} \\ \\ \\frac{\\partial f}{\\partial y} \\ \\ \\frac{\\partial f}{\\partial z}]$$假设一共有m个三维点，n幅图像，那么雅克比矩阵就应该有$i\\times j$行，总的雅克比矩阵可以：$$J = \\left[\\begin{matrix}\\frac{\\partial f}{\\partial r_1^1} &amp;\\frac{\\partial f}{\\partial r_2^1}&amp;\\frac{\\partial f}{\\partial r_3^1} &amp;\\frac{\\partial f}{\\partial t_1^1} &amp;\\frac{\\partial f}{\\partial t_2^1} &amp;\\frac{\\partial f}{\\partial t_3^1} &amp;\\frac{\\partial f}{\\partial x^1} &amp;\\frac{\\partial f}{\\partial y^1} &amp;\\frac{\\partial f}{\\partial z^1} \\\\frac{\\partial f}{\\partial r_1^2} &amp;\\frac{\\partial f}{\\partial r_2^2}&amp;\\frac{\\partial f}{\\partial r_3^2} &amp;\\frac{\\partial f}{\\partial t_1^2} &amp;\\frac{\\partial f}{\\partial t_2^2} &amp;\\frac{\\partial f}{\\partial t_3^2} &amp;\\frac{\\partial f}{\\partial x^1} &amp;\\frac{\\partial f}{\\partial y^1} &amp;\\frac{\\partial f}{\\partial z^1} \\\\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\\\frac{\\partial f}{\\partial r_1^n} &amp;\\frac{\\partial f}{\\partial r_2^n}&amp;\\frac{\\partial f}{\\partial r_3^n} &amp;\\frac{\\partial f}{\\partial t_1^n} &amp;\\frac{\\partial f}{\\partial t_2^n} &amp;\\frac{\\partial f}{\\partial t_3^n} &amp;\\frac{\\partial f}{\\partial x^1} &amp;\\frac{\\partial f}{\\partial y^1} &amp;\\frac{\\partial f}{\\partial z^1} \\\\frac{\\partial f}{\\partial r_1^1} &amp;\\frac{\\partial f}{\\partial r_2^1}&amp;\\frac{\\partial f}{\\partial r_3^1} &amp;\\frac{\\partial f}{\\partial t_1^1} &amp;\\frac{\\partial f}{\\partial t_2^1} &amp;\\frac{\\partial f}{\\partial t_3^1} &amp;\\frac{\\partial f}{\\partial x^2} &amp;\\frac{\\partial f}{\\partial y^2} &amp;\\frac{\\partial f}{\\partial z^2} \\\\frac{\\partial f}{\\partial r_1^2} &amp;\\frac{\\partial f}{\\partial r_2^2}&amp;\\frac{\\partial f}{\\partial r_3^2} &amp;\\frac{\\partial f}{\\partial t_1^2} &amp;\\frac{\\partial f}{\\partial t_2^2} &amp;\\frac{\\partial f}{\\partial t_3^2} &amp;\\frac{\\partial f}{\\partial x^2} &amp;\\frac{\\partial f}{\\partial y^2} &amp;\\frac{\\partial f}{\\partial z^2} \\\\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\\\frac{\\partial f}{\\partial r_1^n} &amp;\\frac{\\partial f}{\\partial r_2^n}&amp;\\frac{\\partial f}{\\partial r_3^n} &amp;\\frac{\\partial f}{\\partial t_1^n} &amp;\\frac{\\partial f}{\\partial t_2^n} &amp;\\frac{\\partial f}{\\partial t_3^n} &amp;\\frac{\\partial f}{\\partial x^2} &amp;\\frac{\\partial f}{\\partial y^2} &amp;\\frac{\\partial f}{\\partial z^2} \\\\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\\\frac{\\partial f}{\\partial r_1^n} &amp;\\frac{\\partial f}{\\partial r_2^n}&amp;\\frac{\\partial f}{\\partial r_3^n} &amp;\\frac{\\partial f}{\\partial t_1^n} &amp;\\frac{\\partial f}{\\partial t_2^n} &amp;\\frac{\\partial f}{\\partial t_3^n} &amp;\\frac{\\partial f}{\\partial x^m} &amp;\\frac{\\partial f}{\\partial y^m} &amp;\\frac{\\partial f}{\\partial z^m} \\\\end{matrix}\\right]$$三维重建一般都有成千上万个三维点和几十上百幅图像，所以雅克比矩阵非常庞大，每次迭代都需要计算一个如此大的矩阵，计算量也是非常巨大的，好在$J$ 是一个稀疏矩阵，也就是说有很多很多项都是0，比如当一个三维点在某一幅图像上没有投影点的时候，对应的那一行就为全为0了。","tags":[{"name":"优化","slug":"优化","permalink":"http://coderic.top/tags/优化/"}]},{"title":"造轮子 | golang | http2简易客户端","date":"2019-06-16T13:54:15.000Z","path":"2019/06/16/gh2c/","text":"最近需要进行http2相关的工作，但是开发环境和测试环境都的curl版本都太老了不支持http2，正好最近在学习golang，于是决定自己造个轮子：用go语言实现一个建议的http2客户端，以本文记录折腾过程。完整代码地址：https://github.com/yiekue/gh2c. 涉及内容： flag包的使用 标准库中http.Client的基本使用 golang中的http2 标准库的flag包平时写程序中免不了根据输入的命令行参数来控制程序的行为，golang的标准库中提供了一个flag包，用于解析命令行输入的各种 - 开头的选项，使用比较方便，免去了自己挨个解析命令行参数的麻烦。 flag包支持bool、string、int等多种类型的选项，使用过程比较简单： 用flag.Bool()、flag.String()等函数定义一个flag，这些函数都有三个入参，依次是flag的名称、默认值、帮助信息，函数的返回值是一个对应类型的 指针 ！指针 ！指针 ！ 在使用变量之前调用flag.Parse()进行解析。如果解析失败，程序会退出，并且打印各个变量的帮助信息，包含名称、默认值、和之前定义的帮助信息。解析会在第一个非 - 开头的参数停止，在非flag参数后面的flag会被忽略。 12345678910111213141516171819202122232425262728293031323334package mainimport ( \"flag\" \"fmt\" \"os\")// 首先定义需要flag的名称、默认值、帮助信息。需要注意的是这里的函数的返回值都是指针var help = flag.Bool(\"help\", false, \"print help info\")var version = flag.Int(\"v\", 2, \"http version 1/2\")var method = flag.String(\"method\", \"GET\", \"http method, GET/POST...\")func main() &#123; // 首先调用Parse()函数进行解析。解析后，前面定义的各种变量就可以直接用了。 flag.Parse() if *help &#123; // 打印选项的默认值和帮助信息 flag.PrintDefaults() os.Exit(0) &#125; switch *version &#123; case 1: fmt.Println(\"HTTP/1.1\") case 2: fmt.Println(\"HTTP/2.0\") default: flag.PrintDefaults() os.Exit(1) &#125; fmt.Println(\"method:\", *method)&#125; 上面这段代码的运行结果： 123[~/code/test]$ go run test.go HTTP/2.0method: GET 由于设置了输出帮助信息的flag默认是false，因此默认不会打印帮助信息，而是打印了另外两个flag的默认值。指定输出帮助信息： 1234567[~/code/test]$ go run test.go -help -help print help info -method string http method, GET/POST... (default &quot;GET&quot;) -v int http version 1/2 (default 2) 设置bool型的flag，只需要在命令行中添加这个flag即可，不需要指定它的值。而对于string之类的flag，就需要指定flag的值： 123[~/code/test]$ go run test.go -v 1 -method &quot;POST&quot;HTTP/1.1method: POST 如果命令行中的flag在代码中没有定义或者flag的输入格式错误，程序会打印错误信息和已定义的flag信息并退出： 12345678910[~/code/test]$ go run test.go -v 1 -metho flag provided but not defined: -methoUsage of /tmp/go-build852894954/b001/exe/test: -help print help info -method string http method, GET/POST... (default &quot;GET&quot;) -v int http version 1/2 (default 2)exit status 2 http.Client &amp;&amp; http2golang的标准库net/http中提供了一个http的客户端，可以进行简单的http操作。但是如果要使用http2就需要额外的golang.org/x/net/http2，由于国内特殊的网络环境，golang.org无法直接访问到，可以到github的镜像仓库中下载使用。同时需要下载http2依赖的text. 使用Client的步骤一般如下： 新建一个http.Client 设置client的各项参数，例如tls参数，http版本等。 使用http.NewRequest()，新建一个请求，并设置请求的请求头等各项参数。 使用client.Do(req)，发送一个请求。 处理请求的响应信息。 使用http.Client发起http请求的流程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package mainimport ( \"crypto/tls\" \"flag\" \"fmt\" \"golang.org/x/net/http2\" \"io/ioutil\" \"net/http\" \"os\")var help = flag.Bool(\"help\", false, \"print help info\")var version = flag.Int(\"v\", 2, \"http version 1/2\")var method = flag.String(\"method\", \"GET\", \"http method, GET/POST...\")func main() &#123; flag.Parse() if *help &#123; flag.PrintDefaults() os.Exit(0) &#125; // 从命令行读取URL，URL需要在各种flag之后 url := flag.Arg(0) if \"\" == url &#123; fmt.Println(\"error: please input URL\") flag.PrintDefaults() &#125; tlsConfig := &amp;tls.Config&#123; InsecureSkipVerify: false, &#125; // 新建一个client client := &amp;http.Client&#123;&#125; // 设置http版本，默认使用http2 switch *version &#123; case 1: client.Transport = &amp;http.Transport&#123; TLSClientConfig: tlsConfig, &#125; case 2: client.Transport = &amp;http2.Transport&#123; TLSClientConfig: tlsConfig, &#125; default: fmt.Println(\"error: unkown http version:\", *version) flag.PrintDefaults() os.Exit(1) &#125; // 使用参数输入的请求方法和url新建一个请求 req, err := http.NewRequest(*method, url, nil) if err != nil &#123; fmt.Println(\"error: failed to create request,\", err) flag.PrintDefaults() os.Exit(1) &#125; // 设置User-Agent req.Header.Set(\"User-Agent\", \"GH2C\") // 发送请求 resp, err := client.Do(req) if nil != err &#123; fmt.Println(\"error: failed to do request,\", err) flag.PrintDefaults() os.Exit(1) &#125; defer resp.Body.Close() // 读取响应体信息 body, err := ioutil.ReadAll(resp.Body) if nil != err &#123; fmt.Println(\"error: failed to read body.\") flag.PrintDefaults() os.Exit(1) &#125; // 答应响应头和响应体长度 fmt.Println(\"&gt;\", resp.Proto, resp.Status) for k, vs := range resp.Header &#123; for _, v := range vs &#123; fmt.Printf(\"&gt; %s: %s\\n\", k, v) &#125; &#125; fmt.Println(\"body.length:\", len(string(body)))&#125; 在网上百度一个支持http2的网站，测试一把，效果如下（域名侵删）： 12345678910111213[~/code/test]$ go run test.go -v 2 https://www.chinacache.com/&gt; HTTP/2.0 200 OK&gt; Content-Type: text/html&gt; Expires: Mon, 17 Jun 2019 04:39:54 GMT&gt; Accept-Ranges: bytes&gt; Age: 19405&gt; Etag: W/&quot;5cdbdbc8-2dc0&quot;&gt; Last-Modified: Wed, 15 May 2019 09:28:40 GMT&gt; Date: Sun, 16 Jun 2019 04:39:54 GMT&gt; Server: nginx&gt; Powered-By-Chinacache: HIT from CMN-CD-b-3g3&gt; Cc_cache: TCP_HITbody.length: 11712 gh2c将在上一节的基础上增加更多的flag来增加更多的功能就成了支持http2的简易拨测工具gh2c： 支持自定义头域 自定义是否忽略证书 更友好的输出信息 12345678910111213141516171819202122*[master][~/code/gh2c]$ ./gh2c -help Usage: ./gh2c -[flags] url -H string custom headers -HKVsep string used for split a custom header key and value (default &quot;:&quot;) -Hsep string used for split custom headers (default &quot;;&quot;) -body output response body -debug print debug info -help print help info -host string custom Host to override default (default &quot;defaltHost&quot;) -method string http method, GET/POST... (default &quot;GET&quot;) -v int http version 1/2 (default 2) -verifyCert enable verification of the server certificate 效果如下，默认不输出body： 12345678910111213141516171819*[master][~/code/gh2c]$ go run gh2c.go -v 2 -H &quot;test:testheadker|test2:testheader2&quot; -Hsep &quot;|&quot; https://example.com/&lt; GET HTTP/2.0 /&lt; Host: www.chinacache.com&lt; Test: testheadker&lt; Test2: testheader2&lt; User-Agent: GH2C&lt;&gt; HTTP/2.0 200 OK&gt; Etag: W/&quot;5cdbdbc8-2dc0&quot;&gt; Last-Modified: Wed, 15 May 2019 09:28:40 GMT&gt; Date: Sun, 16 Jun 2019 04:39:54 GMT&gt; Server: nginx&gt; Cc_cache: TCP_HIT&gt; Accept-Ranges: bytes&gt; Age: 11967&gt; Expires: Mon, 17 Jun 2019 04:39:54 GMT&gt; Powered-By-Chinacache: HIT from CMN-CD-b-3g3&gt; Content-Type: text/html&lt; FIXME在把http2.Transport赋值给client.Transport之后，使用req.Proto获取到的仍然是HTTP/1.1，不知道怎么获取实际使用http版本。","tags":[{"name":"golang","slug":"golang","permalink":"http://coderic.top/tags/golang/"},{"name":"编程","slug":"编程","permalink":"http://coderic.top/tags/编程/"}]}]